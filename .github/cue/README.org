* About CUE (Configure, Unify, Execute)

I am trying out [[https://cuelang.org/][CUE]]. At the moment there are no [[https://cuelang.org/docs/tutorials/tour/intro/schema/][schema definitions]]. It would be
possible to import the [[https://www.schemastore.org/json/][GitHub Workflow JSON schema]] to create one ([[https://youtu.be/Ey3ca0K2h2U?t=1244][video]]). If we
had a schema, we could validate the workflows. However, this is already covered
by [[https://github.com/rhysd/actionlint][actionlint]] which runs through the [[https://github.com/github/super-linter][Super-Linter]] (similar to [[https://github.com/oxsecurity/megalinter][Mega-Linter]]). The
command to import the schema is something like =cue import -l '#Workflow:' -p
github jsonschema: <filename>=.

When we've created some schemas and sub-schemas we can use =cue trim= to remove
boilerplate from the workflows. This is because [[https://cuelang.org/docs/tutorials/tour/intro/constraints/][values defined in a constraint
don't have to be included in the data]].

All of the CUE files here have been created with =cue import=.

One small caveat is that Dependabot won't be able to create pull requests for
the CUE files.

I use [[https://melpa.org/#/cue-mode][cue-mode for Emacs]]. It's fun to press =C-c C-c-= to evaluate the buffer.

* Export to YAML

This is the most primitive way to export CUE files to JSON. A more efficient way
is to use [[https://cuelang.org/docs/usecases/scripting/][the CUE scripting layer]].

#+begin_src sh
cue export --out yaml goreleaser.cue > goreleaser.cue
cue export --out yaml superlinter.cue > superlinter.yml
cue export --out yaml go.cue > go.yml
cue export --out yaml vale.cue > vale.yml
#+end_src

#+RESULTS:

As of writing, all the CUE files in this directory is part of a package called
=whaturl=. It's one big blob of data. That's to say, all the CUE files are
combined into one object. In this form, they're not compatible with GitHub
Actions. This is where [[workflows_tool.cue][workflows_tool.cue]] and [[./workflows.cue][workflows.cue]] come into play.
Files that end with =_tool.cue= are special in CUE ([[https://youtu.be/Ey3ca0K2h2U?t=2223][video]]). They define commands
that you can run with =cue cmd <command_name>=.

So =workflows_tool.cue= defines a command called =genworkflows=. We can run it
with =cue cmd genworkflows=. It creates the YAML files.

From the [[https://cuelang.org/docs/concepts/packages/#file-organization][docs]]:

#+begin_quote
Within a module, all .cue files with the same package name are part of the same
package. A package is evaluated within the context of a certain directory.
Within this context, only the files belonging to that package in that directory
and its ancestor directories within the module are combined. We call that an
instance of a package.
#+end_quote

* Functions

Using [[https://pkg.go.dev/cuelang.org/go/pkg/encoding/json#Marshal][the Marshal function]] to create Slack payloads. We could get a hold of the
Slack schema to verify this struct. OK.

https://github.com/pulumi/pulumi-yaml/tree/main/examples/cue-eks ... .

* Scorecards

- [[https://github.com/ossf/scorecard/blob/main/docs/checks.md#dependency-update-tool][ossf/scorecard: Dependency-Update-Tool]]
- [[https://github.com/ossf/scorecard/blob/main/docs/checks.md#pinned-dependencies][ossf/scorecard: Pinned-Dependencies]]

CUE can be used for policy as code. Pinned dependencies are ensured with the
following CUE code:

#+begin_src cue
_#step: {
	uses?: =~"^[^@]+@[a-f0-9]{40}" // Must pin with SHA1
	...
}
#+end_src
